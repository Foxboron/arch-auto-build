# -*- python -*-
# ex: set filetype=python:

import random
import config

from buildbot.process import remotecommand
from buildbot.plugins import *
from buildbot.plugins import util, steps
from buildbot.process import buildstep, logobserver
from twisted.internet import defer


c = BuildmasterConfig = {}

workers = ["bot1","bot2"]
c['workers'] = [worker.LocalWorker(bot) for bot in workers]


c['protocols'] = {'pb': {'port': 9989}}


c['change_source'] = []
c['change_source'].append(changes.GitPoller(
        'git://github.com/Foxboron/PKGBUILDS.git',
        project='PKGBUILDS',
        workdir='PKGBUILDS', branch='master',
        pollinterval=30))

c['change_source'].append(changes.GitPoller(
        'git://github.com/Foxboron/arch-auto-build.git',
        project='arch-auto-build',
        workdir='arch-auto-build', branch='master',
        pollinterval=30))

c['schedulers'] = []
['schedulers'].append(schedulers.SingleBranchScheduler(
                           name="all",
                           treeStableTimer=None,
                           change_filter = util.ChangeFilter(
                               project = 'PKGBUILDS',
                               branch  = 'master'
                            ),
                           builderNames=["unpack-packages"]))
c['schedulers'].append(
    schedulers.Nightly(name='nightly',
                       branch='master',
                       builderNames=['docker-image'],
                       change_filter = util.ChangeFilter(
                           project = 'arch-auto-build',
                           branch  = 'master'
                        ),
                       hour=3, minute=0))

sch = schedulers.ForceScheduler(
        name="force",
        buttonName="Build package",
        label="Build package",
        builderNames=["unpack-packages"],

        codebases=[
            util.CodebaseParameter(
                "",
                name="PKGBUILDS",
                branch=util.ChoiceStringParameter(
                    name="branch",
                    choices=["master"],
                    default="master"),

                revision=util.FixedParameter(name="revision", default=""),
                repository=util.FixedParameter(name="repository", default=""),
                project=util.FixedParameter(name="project", default=""),
                ),
            ],

        properties=[
            util.StringParameter(name="build_package",
                label="Package:", default="",
                required=False, size=80),
            util.StringParameter(name="build_with_dependency",
                label="Build package with dependency:", default="",
                required=False, size=80),
            util.StringParameter(name="repo",
                label="Repository:", default="foxboron",
                required=False, size=80),
            util.BooleanParameter(name="build_all_packages",
                                  label="Build all packages",
                                  default=False)
            ]
    )

docker = schedulers.ForceScheduler(
            name="force-docker",
            buttonName="Build docker image",
            label="Build docker image",
            builderNames=["docker-image"],
            codebases=[""])

c['schedulers'].append(sch)     
c['schedulers'].append(docker)     
c['schedulers'].append(schedulers.Triggerable(name="build", builderNames=["build-package"]))


class TriggerWithPackageNames(steps.Trigger, buildstep.ShellMixin):

    def assign_build_props(self, name, dependencies, worker=False):
        """Assign propper build properties"""
        props = self.set_properties.copy()
        props["virtual_builder_name"] = name 
        props["package"] = name 
        props["dependencies"] = dependencies 
        if worker:
            props["workername"] = worker
        return ["build", props]

    def add_build(self, package, needed, worker=False):
        """Check if the build is allready inn the list"""
        if package not in self._build_requests:
            self.sp.append(self.assign_build_props(package, needed, worker=worker))
            self._build_requests.append(package)

    def resolve(self, name, packages, graph=[]):
        """Poor mans dependency resolver """
        available = list(packages.keys())
        for i in packages[name]:
            if i in available and i not in graph:
                graph.append(i)
                self.resolve(i, packages, graph=graph)
        return graph

    def extract_deps(self, srcinfo):
        """ Poor mans .SRCINFO parser """
        packages={}
        pkgname=""

        for i in srcinfo.split("\n"):
            if not i:
                continue
            if i[0] == "#":
                continue
            option = i.strip() 
            key,value = option.split(" = ")
            if key == "pkgbase":
                pkgname=value
                packages[pkgname] = []
            if key == "makedepends":
                packages[pkgname].append(value)
            if key == "depends":
                packages[pkgname].append(value)
        return packages

    def add_package(self, package):
        """Adds a pacakge to our build trigger list"""
        if package in self.repo_config["ignore"]:
            return

        # Worker for dependenant builds
        worker=False
        needed = self.resolve(package, self.dependencies, graph=[])

        # If we want to build against a dependency, and it's not inn the list; abort
        if self.getProperty("build_with_dependency") and self.getProperty("build_with_dependency") not in needed:
            return

        if needed:
            worker = random.choice(workers)

        # Run over all needed packages and find their deps
        for i in needed:
            _needed = self.resolve(i, self.dependencies, graph=[])
            self.add_build(i, _needed, worker=worker)
        self.add_build(package, needed, worker=worker)

    @defer.inlineCallbacks
    def getSchedulersAndProperties(self):
        """Bread and butter.
        This triggers all the needed PKGBUILDS and resolves the dependencies"""
        self.sp = []
        self._build_requests = []
        self.repo_config = {"ignore":[]}

        self.observer = logobserver.BufferLogObserver()
        self.addLogObserver('stdio', self.observer)
        cmd = yield self.makeRemoteShellCommand(command=['cat', '.buildrc'])
        yield self.runCommand(cmd)
        buildrc = self.observer.getStdout()
        if buildrc:
            self.repo_config = json.loads(buildrc)

        # I simply dont know how to make the yield stuff recursive
        # so we find all .SRCINFOs available and make a list
        self.observer = logobserver.BufferLogObserver()
        self.addLogObserver('stdio', self.observer)
        cmd = yield self.makeRemoteShellCommand(command="cat */.SRCINFO")
        yield self.runCommand(cmd)
        self.dependencies = self.extract_deps(self.observer.getStdout())


        # Build one package from the force scheduler 
        if self.getProperty("build_package"):
            package = self.getProperty("build_package")
            self.add_package(package)
            return self.sp
       
       # Build all packages
        if self.getProperty("build_all_packages"):
            for package in dependencies.keys():
                self.add_package(package)
            return self.sp

        # Only build changes PKGBUILDS
        # And no, i don't know how to remove the output from
        # self.observer :c
        self.observer = logobserver.BufferLogObserver()
        self.addLogObserver('stdio', self.observer)
        cmd = yield self.makeRemoteShellCommand(command=["git", "diff","--name-only","HEAD~1"])
        yield self.runCommand(cmd)

        packages = []
        for i in self.observer.getStdout().split():
            file = i.split("/")[0]
            if file in available_packages and file not in repo_config["ignore"]: 
                packages.append(file)
    
        for package in set(packages):
            self.add_package(package)
        return self.sp


unpack_packages = util.BuildFactory()
unpack_packages.addStep(steps.Git(repourl='git://github.com/Foxboron/PKGBUILDS.git', mode='incremental'))
unpack_packages.addStep(TriggerWithPackageNames(schedulerNames=['build'], waitForFinish=True, updateSourceStamp=True))

build_package = util.BuildFactory()
build_package.addStep(steps.Git(repourl='git://github.com/Foxboron/PKGBUILDS.git', mode='incremental', haltOnFailure=True))

@util.renderer
def makeCommand(props):
    options = {}
    options["pkg"] = props.getProperty('package')
    options["repo"] = props.getProperty('repo')

    build = "build-package {repo} {pkg}".format(**options)
    return build.split(' ')

build_package.addStep(steps.ShellCommand(command=makeCommand, haltOnFailure=True))

docker_image = util.BuildFactory()
docker_image.addStep([steps.Git(repourl='git://github.com/Foxboron/arch-auto-build.git', mode='incremental', haltOnFailure=True)])
docker_image.addStep([steps.ShellCommand(command=["./build-docker.sh", "foxboron"], workdir="build/docker")])

c['builders'] = []
c['builders'].append(
    util.BuilderConfig(name="unpack-packages",
        workernames=[bot for bot in workers],
        factory=unpack_packages))

c['builders'].append(
    util.BuilderConfig(name="build-package",
        collapseRequests=False,
        canStartBuild=util.enforceChosenWorker,
        workernames=[bot for bot in workers],
        factory=build_package,
        properties={"repo": "foxboron"}))

c['builders'].append(
    util.BuilderConfig(name="docker-image",
        workernames=[bot for bot in workers],
        factory=docker_image))

irc = reporters.IRC(host="irc.velox.pw",
                    port=6697,
                    useSSL=True,
                    nick="builder",
                    notify_events={
                        'finished': 1,
                        'started': 1,
                    },
                    channels=[{"channel": "#builds"}])
c['services'] = [irc]


c['title'] = "Foxboron Packages"
c['titleURL'] = "https://build.velox.pw"
c['buildbotURL'] = "https://build.velox.pw/"


authz = util.Authz(
    allowRules=[
        util.StopBuildEndpointMatcher(role="admin"),
        util.RebuildBuildEndpointMatcher(role="admin"),
        util.ForceBuildEndpointMatcher(role="admin"),
        util.EnableSchedulerEndpointMatcher(role="admin"),
        util.AnyControlEndpointMatcher(role="admins"),
    ],
    roleMatchers=[
        util.RolesFromEmails(admins=["admin"])
    ]
)

auth=util.UserPasswordAuth(config.users)



c['www'] = dict(port=8010,
                plugins=dict(waterfall_view={}, console_view={}))

c['www']['auth'] = auth
c['www']['authz'] = authz

c['db'] = {
    'db_url' : "sqlite:///state.sqlite",
}
